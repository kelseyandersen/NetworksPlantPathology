---
title: "Visualizing and Describing Networks"
author: "Kelsey Andersen, Robin Choudhury, & James Fulton"
---

#### Slides for this section can be downloaded here:
* [Intro to Networks in R](PDFFiles/ICPP2018_IntroToNetworks.pdf)

## Networks with igraph 

First, make sure you have loaded package *igraph*. 
```{r}
#install.packages("igraph")
library(igraph)
```

### Simple Networks

First, create a simple adjacency matrix with three rows and three columns 
```{r}
mat1 <- matrix(c(0, 1, 0, 0, 0, 1, 1,0, 0), nrow=3, ncol=3) ### matrix function 
mat1
```


Use the igraph function *graph_from_adjacency_matrix()* to create a network object from your graph, then use the *plot()* function to plot. 
```{r}
mat2 <- graph_from_adjacency_matrix(mat1)
plot(mat2, edge.arrow.size = 1) ## set the size of the arrows 
```
\  

Alternatively, create the same network by telling igraph what links you would like.  

```{r}
mat3 <- graph(edges=c(1,3, 3,2, 2,1), n=3, directed=T ) # use graph function and list edges 
plot(mat3, edge.arrow.size = 1)
```
\  
## Network Aestetics  
Many parts of a network can be sized and colored to help communicate results more clearly.  
Here, for example, we color the nodes and change the size and position of the labels using *vertex.color =* and *vertex.label.dist =*

```{r}
plot(mat3, edge.arrow.size = 1, vertex.color = "purple", vertex.size = 20, vertex.label.cex = 2, vertex.label.dist = 3.5)

```

### Generating Random Networks   
Networks can also be generated randomly  
\  
Here we create an empty graph (no links):  

```{r}
eg <- make_empty_graph(50) ## make a graph with 50 nodes
plot(eg, vertex.size=10, vertex.label=NA, vertex.color = "plum") ## no node labels.
eg # view graph object


```

And a full graph (all possible links = 780): 

```{r}
fg <- make_full_graph(40)
plot(fg, vertex.size=10, vertex.label=NA, vertex.color = "plum")
fg # view graph
```
\  

Or a tree graph:
```{r}
tr <- make_tree(40, children = 3, mode = "undirected")
plot(tr, vertex.size=10, vertex.label=NA, vertex.color = "plum") 
```
\ 
You can also generate mathmatical models of networks in igraph. For example, a very simple model can be generated by using *sample_gnm()* to generate a graph of a specified number of nodes (n) and links (m). Links will be generated with the same constant probability.  
\  

Erdos-Renyi random graph (Again, ‘n’ is number of nodes, ‘m’ is the number of edges).
```{r}
er <- sample_gnm(n=100, m=40) 
plot(er, vertex.size=5, vertex.label=NA, vertex.color = "plum") # vertex color "plum" :)
```


Barabasi-Albert scale-free graph (preferential attachment). This function builds a model with a simple stochastic algorithm where n = the number of nodes & power= the power of the preferential attachment. The default is 1, which gives linear attachment. Try changing the value of *power =* to 2 and 3 and see what happens! (m = the number of edges to add in each step). 
```{r}
ba <-  sample_pa(n=100, power=1, m=1,  directed=F)
plot(ba, vertex.size=6, vertex.label=NA, vertex.color = "plum")
```


## Network data types  

### Adjacency matrices
\  
You can read in your data directly as an adjacency matrix, but likely this is not the way that you have your data organized. Instead, it might be easier to have two files: a *node* file and an *edge* file.  

In a node file, the first two columns are all of your from:to links. Column 1 is always *from*, Column 2 is always *to* (less important for undirected networks). The columns after that are your edge attributes (such as weight of link, volume, probability, name etc).  
\  

Here is an example of a simple node list, where all of the nodes are farmers. We include attributes about the *node* like age, gender and number of years farming.  
```{r}
Nodelist <- data.frame(
                    Names =c("Jim", "Carole", "Joe", "Michelle", "Jen", "Pete", "Paul", "Tim", 
                            "Jess", "Mark", "Jill", "Cam", "Kate") ,
                    YearsFarming = c(8.5, 6.5, 4, 1, 3, 10, 5, 5, 5, 1, 1, 6, 6) , 
                    Age = c(22, 31, 25, 21, 22, 35, 42, 27, 26, 33, 26, 28, 22) , 
                    Gender = c("Male", "Female", "Male", "Female", "Female", "Male","Male","Male", "Female", "Male", "Female", "Male", "Female"))
Nodelist       
```
\  

Now an edgelist- Who shared information in the 2017 growing season? How frequently? 
```{r}
Edgelist <- data.frame(
                  From = c("Jim", "Jim", "Jim", "Jill", "Kate", "Pete", "Pete", "Jess", "Jim", "Jim", "Pete"),
                  To = c("Carole", "Jen", "Pete", "Carole", "Joe", "Carole", "Paul", "Mark", "Cam", "Mark", "Tim")
)

```


### igraph objects

Let's make our farmer communication network!
```{r}
FarmNetwork <- graph_from_data_frame(d = Edgelist, vertices = Nodelist, directed = T)
FarmNetwork
E(FarmNetwork) # view edges
V(FarmNetwork) # view nodes
```


Plot!
```{r}
plot(FarmNetwork, edge.arrow.size = .5, vertex.color = "plum", vertex.label.dist = 2.5)

```

### Fancy Stuff
 Much more information about making beautiful networks in R using igraph can be found at [Katya Ognyanova's Site](http://kateto.net/networks-r-igraph). But briefly:  
\  
Let's color our nodes based on gender
```{r}
colrs <- c("gray70", "blue")
V(FarmNetwork)$color <- ifelse(V(FarmNetwork)$Gender == "Male", "orange", "dodgerblue") ## if male, make orange, if not, blue. Go gators!!!!   
plot(FarmNetwork, edge.arrow.size = .5, vertex.label.dist = 2.5)

```


\  
You can also size your nodes based on attributes:
```{r}

V(FarmNetwork)$size <- V(FarmNetwork)$YearsFarming # size the nodes by number of years farming
plot(FarmNetwork, edge.arrow.size = .5, vertex.label.dist = 2.5)

```

Scale the node size up a bit.. 
```{r}

V(FarmNetwork)$size <- V(FarmNetwork)$YearsFarming *2 ## scale by multiplying by 2
plot(FarmNetwork, edge.arrow.size = .5, vertex.label.dist = 2.5)

```

## Describing networks  
\  

### Node-Level Statistics  
* **Degree centrality**- The number of links a node has to other nodes in the network (both incoming and outgoing)  
* **Eigenvectory centrality**- A weighted sum reflecting both direct links to a node (degree) and the node degree of neighbors  
* **Betweenness centrality**- The number of shortest paths through the network of which a node is a part  
* **Closeness centrality**- The inverse of the average length of the shortest path to/from all the other nodes in the network   

Use igraph "graph" function to plot a network directly as igraph object. We will use this as an example.   
```{r}
Net2 <- graph(edges=c(1,3, 3,2, 2,1, 2,4, 5,4), n=5, directed=T) 
Net2
plot(Net2, edge.arrow.size = .5, vertex.color = "gold")
```

#### Node degree centrality 


What is the node *degree* of the nodes in our graph, which is the sum of the number of both incoming and outgoing links.  
```{r}
deg1 <-  degree(Net2, v = V(Net2), mode = c("all"))
deg1 ## node degree of all nodes in the network 
V(Net2)$size <- (deg1*10) #size the network nodes by their node degree 
plot(Net2, edge.arrow.size = .5, vertex.color = "gold") ## is this what you expected?
```

\  
#### Node eigenvector centrality  

**Eigenvector centrality**- Takes into account not only how many links that the node has, but also the number of links that connected nodes have. It is an extension of degree centrality. Note: this could potentially be important in epidemiology because disease risk may become higher if a node is connected to more highly connected nodes, even if the node itself does not have many links. 

```{r}
eig1 <- eigen_centrality(Net2, directed = TRUE)
eig1 ## NOTE: this gives a "list" of vectors. To pull the eigenvector centrality scores we need to look at 
eig1$vector #like this!
V(Net2)$size <- (eig1$vector*10) #size the network nodes by eigenvector centrality 
plot(Net2, edge.arrow.size = .5, vertex.color = "gold") ## is this what you expected?
```

#### Node betweenness centrality

What is the *betweenness centrality* of the nodes in our graph, which is the number of shortest paths through the network of which a node is a part  
```{r}
bet1 <-  betweenness(Net2, v = V(Net2), directed = TRUE)
bet1 ## node degree of all nodes in the network 
V(Net2)$size <- (bet1*10) #size the network nodes by their node degree 
plot(Net2, edge.arrow.size = .5, vertex.color = "gold") ## is this what you expected?
```

#### Node closeness centrality

What is the *closeness centrality* of the nodes in our graph, The inverse of the average length of the shortest path to/from all the other nodes in the network. 
```{r}
cls1 <-  closeness(Net2, v = V(Net2), mode = "all")
cls1 ## closeness centrality of all nodes in the network
V(Net2)$size <- (cls1*100) #size the network nodes by their node closeness
plot(Net2, edge.arrow.size = .5, vertex.color = "gold") ## is this what you expected?
```
\ 

### Graph level statistics

Calculate graph **density** (ratio of edges to number of possible edges), **diameter** (length of the longest path across the graph), **mean distance** (mean path length)
```{r}
igraph::graph.density(Net2) #graph density
diameter(Net2) # diameter
mean_distance(Net2) ##mean path length
```




```{r}
igraph::vertex_connectivity(Net2)
igraph::transitivity(Net2)
```
## Bonus: Does my network deviate from random?  

One way to see if my network has an structure to it that is different than what would be generated is to compare to many randomaly generated graphs of the same size (nodes and links).   
\  


Lets go back to our farmer example!!
```{r}
library(igraph)
plot(FarmNetwork)
Degree_Distribution <- igraph::degree(FarmNetwork, mode = "total")
hist(Degree_Distribution)
```

same number of nodes and links
```{r}
new1 <- sample_gnm(13, 11, directed = FALSE, loops = FALSE)
h1<- igraph::degree(new1)
hist(h1)
```


Make a loop to generate 50 random graphs with that same number of nodes and links! 
```{r}
degamat <- NULL
n <- 50
for(i in 1:n){
  newmatrix <- sample_gnm(13,11, directed = FALSE, loops = FALSE)
  degmat <- igraph::degree(newmatrix)
  degamat<-rbind(degamat,degmat)
}
degamat

hist(degamat, xlim = c(0,7), breaks = 7)
```

Graph and compare the degree distribution of our surveyed graph with degree distribution of our random networks.  
* How do they compare? 
* Do we think there are underlyng social processes that are driving link formation in this network? 
* What could they be?
* You might say that a few people are hightly connected but most are more sparsley connected than we would expect by random. 

```{r}
par(mfrow=c(1,1),
    mar=c(2,2,2,2))
hist(Degree_Distribution, xlab = "Node Degree", xlim = c(0,7), breaks = 3, main = "Observed")
hist(degamat, xlim = c(0,7), breaks = 7, xlab = "Node Degree", main = "Simulated")
```
